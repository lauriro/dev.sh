#!/bin/sh
#
# Host a git server
#
#    @version  18.9.0
#    @author   Lauri Rooden - https://github.com/lauriro/git-serv
#    @license  MIT License  - http://lauri.rooden.ee/mit-license.txt
#
#-
#- Available commands are:
#-    help [command]
#-    user [add|delete|conf|addkey|info] <username>
#-    repo [init|info|rename|conf|drop] <project.git>
#-
#- See 'help <command>' to read about a specific command.
#-
#repo-
#repo- EXAMPLES
#repo-
#repo-    git> repo init test.git
#repo-    git> repo drop test.git
#repo-
#repo-   repo
#repo-   repo test.git init
#repo-   repo test.git config access.read all
#repo-   repo test.git config access.write admin,richard
#repo-   repo test.git config access.write.devel all
#repo-   repo test.git config access.tag richard
#repo-   repo test.git config branch.master.denyDeletes true
#repo-   repo test.git config branch.master.mergeoptions "--ff-only"
#repo-   repo test.git config branch.devel.mergeoptions "--no-ff"
#repo-   repo test.git config tags.denyOverwrite true
#repo-   repo test.git describe "My cool repo"
#repo-   repo test.git fork new_repo.git
#user-
#user- EXAMPLES
#user-
#user-    git> user add john
#user-    git> user conf john group admin
#user-    git> user conf john name "John Smith"
#user-    git> user addkey john
#user-    git> user rmkey john fingerprint
#user-    git> user find
#user-    git> user find john
#user-    git> user show john
#user-    git> user drop john
#user-


export LC_ALL=C

CMD=${SSH_ORIGINAL_COMMAND-"$*"}
KEY=$HOME/.ssh/authorized_keys
LOG=$HOME/log/gitserv-$(date -u +%F).log
ROOT=$HOME/repo
WHO="${SSH_CLIENT-${SUDO_USER+sudo}} local"
WHO="${WHO%% *} ${SUDO_USER-$USER}"

REPO_RE='[-a-z0-9_.]\{0,30\}.git$'
USER_RE='[a-z][-_a-z0-9]\{1,16\}[a-z0-9]$'
LINE='command="env USER=%s GROUP=%s %s",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty %s\n'

log() {
	printf "%s %s: %s -- %s\n" "$(date -u +"%F %TZ")" "$WHO" "$1" "$CMD" >> $LOG
}

die() {
	printf "ERROR: %s%s\n" "$1" "${2+"\\nERROR: "}$2" >&2
	log "$1" error
	exit 2
}

# deny Ctrl-C and unwanted chars
trap "die \"trap $LINENO\";kill -9 $$" 1 2 3 6 15
test -r "${CONF=$0.conf}" && . "$CONF"
expr "$CMD " : '[-a-zA-Z0-9_ +./,'\''@=|:]*$' >/dev/null || die "DON'T BE NAUGHTY"

doc() {
	sed -n "/^#$1- \?/s///p" $0
}

warn() {
	printf "WARNING: %s%s\n" "$1" "${2+"\\nWARNING: "}$2" >&2
	log "$1" error
}

conf() {
	git config --file "${FORK:-$REPO/config}" $@
}

user_conf() {
	git config --file "users.conf" "$@"
}

acc() {
	re=$(conf "access.$1")
	re=$re${re:+"\|"}$(conf "repo.owner")
	expr ",all,$USER,$GROUP," : ".*,\($re\)," >/dev/null
	test "$?" = "${2:-0}" || die "${3:-"Repo '$1' does not exists"}"
}

resolve_repo() {
	cd "$ROOT" >/dev/null 2>&1 || die "Setup first"
	# unquote repo name
	REPO=${1%\'}
	REPO=${REPO#*\'}

	# Ensure repo ends with `.git`
	REPO=${REPO%.git}.git

	# When repo is a file then it is a fork or in other backend
	if [ -f "$REPO" ]; then
		FORK=$REPO
		REPO=$(conf fork.upstream)
		BACKEND=$(conf fork.backend)
	fi
}

user_exists() {
	expr "$1" : "$USER_RE" >/dev/null 2>&1
	test "$?" = "0" || die "Name '$1' is not available" "It should match to ^$USER_RE"
	test -n "$(user_conf "user.$1.created")"
	test "$?" = "${2:-0}" || die "${3:-"User '$1' does not exists"}"
}

is_admin() {
	test -z "$SSH_CLIENT" || expr ",$USER,$GROUP," : ".*,admin," >/dev/null
	test "$?" = "${2:-0}" || die "${3:-"Admin access denied"}"
}

column() {
	sort | \
	sed -e '100,100s/.*/.../' -e '101,$d' -e ${1:-"s/^user\.\|\.created .*//g"} | \
	git column --mode=auto --padding=2 --indent="   "
}

ask() {
	printf "${1:-"Are you sure?"} [${2:-"Y/n"}] "
	while read r; do
		case "$r${2:-"Y/n"}" in
			y*|Y*) return 0 ;;
			n*|N*) return 1 ;;
			*) printf "Please answer yes or no." ;;
		esac
	done
}


valid() {
	expr "$2" : "$1" >/dev/null
	test "$?$3" = "0" || die "Name '$2' is not available" "It should match to ^$1"
}





set -- $CMD

case "$1" in
git-*)   # git pull and push git-(upload|receive)-pack
	resolve_repo "$2"
	[ $1 = git-receive-pack ] && acc write "WRITE ACCESS DENIED" || acc read
	if [ -n "$BACKEND" ]; then
		SIZE=$(expr length "$1$REPO$BACKEND" + 13)
		PIPE=$(mktemp -u)
		mkfifo -m 600 $PIPE
		exec 4<>"$PIPE"
		nc localhost 9418 <&4 &
		printf "%04x%s /%s\0host=%s\0" $SIZE "$1" "$REPO" "$BACKEND" >&4
		cat - >&4
		rm $PIPE
	else
		env GIT_NAMESPACE=$FORK git shell -c "$1 '$REPO'"
	fi
	;;
user)
	is_admin
	case $2 in
	add)
		user_exists "$2" 1 "Name '$2' is not available"
		user_conf "user.$2.created" "$TIME"
		user_conf "user.$2.group" "all"
		printf "User '%s' added\n" "$2"
		;;
	drop)
		user_exists "$2"
		if ask "Drop user '$2'?" "N/y"; then
			user_conf --get-regexp "^user\.$2\." >> "$TIME.$2.conf"
			user_conf --remove-section "user.$2"
			sed -ie "/ USER=$2 /d" $KEY
			printf "User '%s' dropped\n" "$2"
		fi
		;;
	addkey)
		user_exists "$2"
		printf "Input the key (ssh-rsa AAAAB3Nza...): "
		read KEY
		TMP=$(mktemp -u)
		printf %s "$KEY" > $TMP
		ssh-keygen -lf $TMP > $TMP.fp 2>/dev/null || die "Invalid key"
		read len FP note <$TMP.fp
		rm $TMP $TMP.fp

		test -n "$(user_conf "key.$FP.created")" && die "Key exists"

		user_conf "key.$FP.created" "$TIME"
		user_conf "key.$FP.owner" "$2"
		user_conf "key.$FP.note" "${note#/tmp/* }"

		printf "$LINE" "$2" "$HOME/gitserv" "$KEY" >> $KEY
		printf "Key '%s' added for '%s'\n" "$FP" "$2"
		;;
	rmkey)
		test -n "$(user_conf "key.$2.created")" || die "Key not exists"
		user_conf --remove-section "key.$2"
		;;
	conf)
		user_exists "$2"
		user_conf ${4:+"--replace-all"} "user.$2.$3" ${4:+"$4"}
		;;
	group)
		user_exists "$2"
		user_conf ${4:+"--replace-all"} "user.$2.$3" ${4:+"$4"}
		;;
	show)
		user_exists "$2"
		user_conf --get-regexp "^user\.$2\."
		;;
	find)
		printf "LIST OF USERS:${2:+" (filter: ${2:-*})"}\n"
		user_conf --get-regexp "^user\.$2.*\.created$" | column
		;;
	*)
		doc user;;
	esac
	;;
repo)
	is_admin

	repo_exists() {
		expr "$1" : "$REPO_RE" >/dev/null 2>&1
		test "$?" = "0" || die "Name '$1' is not available" "It should match to ^$REPO_RE"
		test -n "$(conf "repo.created")"
		test "$?" = "${2:-0}" || die "${3:-"Repo '$1' does not exists"}"
	}

	valid_branch_name() {
		MSG="we do not like '$1' as a branch name"
		expr "$1" : '[-a-zA-Z0-9_ +./,'\''@=]*$' >/dev/null || die "$MSG"
		git check-ref-format "refs/heads/$1" || die "$MSG"
		#return $?
	}

	resolve_repo "$2"

	case $1 in
	init)
		repo_exists "$REPO" 1 "Name '$REPO' is not available"
		git init --template=$HOME/template --bare --shared -q "$REPO"

		conf repo.owner "$USER"
		conf repo.created "$TIME"
		conf repo.createdBy "$USER"
		conf transfer.hiderefs refs/namespaces

		printf "Repo %s created\n" "$REPO"

		ln -st $REPO/hooks $HOME/hooks/update $HOME/hooks/post-receive $HOME/hooks/pre-receive
		;;
	fork)
		repo_exists "$REPO"
		FORK="$3"
		repo_exists "$REPO" 1 "'$3' is not available"
		[ "${3%/*}" = "$3" ] || mkdir -p ${3%/*}
		conf fork.upstream "$REPO"
		printf "Fork %s created\n" "$3"
		;;
	conf)
		repo_exists "$REPO"
		# set default branch
		#git symbolic-ref HEAD refs/heads/master
		# make `git pull` on master always use rebase
		#$ git config branch.master.rebase true
		#You can also set up a global option 
		# to set the last property for every new tracked branch:

		# setup rebase for every tracking branch
		#$ git config --global branch.autosetuprebase always


		#Fetch a group of remotes
		#$ git config remotes.default 'origin mislav staging'
		#$ git remote update
		# fetches remotes "origin", "mislav", and "staging"
		# You can also define a named group like so:
		#$ git config remotes.mygroup 'remote1 remote2 ...'
		#$ git fetch mygroup
		conf "${3-'-l'}" "$4"
		#conf "repo.$1.$3" "$4"
		;;
	rename)
		repo_exists "$REPO"
		repo_exists "$3" 1 "'$3' is not available"
		mv "$REPO" "$3"
		printf "Repo '%s' renamed to '%s'\n" "$REPO" "$3"
		;;
	drop)
		# Warning: These steps will permanently delete the repository, wiki, issues, and comments.
		# This action cannot be undone.
		# Please also keep in mind that:
		# - Deleting a private repository will delete all of its forks.

		if ask "Delete repo '$1'?" "N/y"; then
			tar -czf "$TIME.$2.tar.gz" $2
			rm -rf $2
			if [ "$REPO" != "$2" ]; then
				rm -rf "$REPO/refs/namespaces/$2"
			fi
		fi
		;;
	def*)
		env GIT_NAMESPACE=$FORK git --git-dir "$REPO" symbolic-ref HEAD refs/heads/$4
		;;
	info)
		repo_exists "$REPO" || die "Repo not found"
		ACC_R=$(conf repo\.${1}\.read | sed 's/|/\|/')
		ACC_W=$(conf repo\.${1}\.write)
		printf "Repo:  %s\n" "$1 [R:$ACC_R W:$ACC_W]"
		printf "Owner: %s\n" "$(conf repo\.${1}\.owner)"
		printf "Size:  %s\n" "$(test -e "$1" && du -hs $1|cut -f1 || echo "- not local -")"
		printf "\nLIST OF USERS WITH ACCESS:   (* = write)\n"
		{
			test -n "$ACC_W" && conf --get-regexp "^user\..*\.group" "$ACC_W" |\
			sed -e 's/^user.//' -e 's/.group .*/*/'
			test -n "$ACC_R" && conf --get-regexp "^user\..*\.group" "$ACC_R" |\
			sed -e 's/^user.//' -e 's/.group .*//'
		} | sort -du | column
		# - $(cat $REPO/description)\nSize: $(du -hs $2|cut -f1)\n\nPermissions:\n"
		#conf --get-regexp '^access\.' | tr ",=" "| " | while read name RE;do
		#	echo "$name [$RE] - $(get_users|grep -E "\\b($RE)\\b"|cut -d" " -f1|sort|tr "\n" " ")"
		#done
		;;
	find)
		printf "LIST OF REPOSITORIES:${2:+" (filter: ${2:-*})"}\n"
		{
			grep -Ilr --include=config '^\s*bare = true' *
			grep -Ir --include=*.git '^\s*upstream = .*' *
		} 2>/dev/null | sed -e 's,/config$,,;s/:.*= /->/' | column "/${2:-.}/!d"
		;;
	*)
		doc repo;;
	esac
esac





# Assigns the original repository to a remote called "upstream"
# if [ -n "$FORK" ]; then
#	printf "%s is a fork, you may want to add an upstream:\n" "$FORK" >&2
#	printf "   git remote add upstream %s\n" "$REPO" >&2
# fi
# remote: This repository moved. Please use the new location:
# remote:   https://github.com/lauriro/lauriro.git
